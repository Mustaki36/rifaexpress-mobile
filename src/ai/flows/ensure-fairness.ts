// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview A raffle winner selection AI agent that uses a verifiable fairness algorithm.
 *
 * - ensureFairness - A function that handles the raffle winner selection process.
 * - EnsureFairnessInput - The input type for the ensureFairness function.
 * - EnsureFairnessOutput - The return type for the ensureFairness function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import crypto from 'crypto';

const EnsureFairnessInputSchema = z.object({
  raffleEntries: z.array(z.string()).describe('An array of raffle entry IDs.'),
  raffleId: z.string().describe('The ID of the raffle.'),
  winningSeed: z.string().describe('A random seed to ensure fairness. This should be a publicly verifiable random string.'),
});
export type EnsureFairnessInput = z.infer<typeof EnsureFairnessInputSchema>;

const EnsureFairnessOutputSchema = z.object({
  winningEntry: z.string().describe('The ID of the winning raffle entry.'),
  fairnessProof: z.string().describe('A cryptographic proof of the fairness of the selection process.'),
});
export type EnsureFairnessOutput = z.infer<typeof EnsureFairnessOutputSchema>;

export async function ensureFairness(input: EnsureFairnessInput): Promise<EnsureFairnessOutput> {
  return ensureFairnessFlow(input);
}

const prompt = ai.definePrompt({
  name: 'ensureFairnessPrompt',
  input: {schema: EnsureFairnessInputSchema},
  output: {schema: EnsureFairnessOutputSchema},
  prompt: `You are a provably fair raffle selector. Given a list of raffle entries, a raffle ID, and a winning seed, you will select a single winning entry.

The selection process must be verifiable. Use the following algorithm:

1.  Concatenate the raffle ID, the winning seed, and each raffle entry ID.
2.  Hash the concatenated string using SHA256.
3.  Convert the hexadecimal hash to an integer.
4.  Take the modulo of the integer with the number of raffle entries.
5.  The entry at that index is the winner.
6.  Return the winning entry ID and the SHA256 hash as the fairness proof.

Raffle Entries: {{raffleEntries}}
Raffle ID: {{raffleId}}
Winning Seed: {{winningSeed}}`,
});

const ensureFairnessFlow = ai.defineFlow(
  {
    name: 'ensureFairnessFlow',
    inputSchema: EnsureFairnessInputSchema,
    outputSchema: EnsureFairnessOutputSchema,
  },
  async input => {
    const {raffleEntries, raffleId, winningSeed} = input;

    if (!raffleEntries || raffleEntries.length === 0) {
      throw new Error('No raffle entries provided.');
    }

    const combined = `${raffleId}-${winningSeed}`;

    const hashedEntries = raffleEntries.map(entry => {
      const combinedString = combined + `-${entry}`;
      const hash = crypto.createHash('sha256').update(combinedString).digest('hex');
      return {entry, hash};
    });

    const hashValues = hashedEntries.map(e => parseInt(e.hash, 16));
    const totalEntries = raffleEntries.length;
    const winningIndex = hashValues.reduce((a, b) => a + b, 0) % totalEntries;
    const winningEntry = raffleEntries[winningIndex];
    const fairnessProof = hashedEntries[winningIndex].hash;

    return {
      winningEntry: winningEntry,
      fairnessProof: fairnessProof,
    };
  }
);
